package glcore

import kotlin.reflect.KClass

/*****************************************************************************************
 *
 * This file is generated by GlDataDeclareGen.py
 * You should update GlDataDeclare.json instead of updating this file by manual.
 *
 * ***************************************************************************************/

// -------------------------------------------------------------------------------------------------

open class TaskData : IGlDeclare() {
    var id: String = ""
    var name: String = ""
    var color: String = ""
    
    override var uuid: String = randomUUID()
    
    val structDeclare = mapOf< String, KClass< * > >(
        "id" to String::class, 
        "name" to String::class, 
        "color" to String::class
    )
    
    companion object {
        fun fromAnyStructList(anyStructList: List< * >): List< TaskData > {
            return mutableListOf< TaskData >().apply {
                for (anyStruct in anyStructList) {
                    val data = TaskData().apply { fromAnyStruct(anyStruct) }
                    if (data.dataValid) {
                        this.add(data)
                    }
                }
            }
        }
    }

    override fun fromAnyStruct(data: Any?): Boolean {
        val anyStruct = castToAnyStruct(data)
        dataValid = if (checkStruct(anyStruct, structDeclare)) {
            uuid = (anyStruct.get("uuid") as? String) ?: uuid
            
            id = anyStruct.get("id") as String
            name = anyStruct.get("name") as String
            color = anyStruct.get("color") as String
            true
        }
        else {
            false
        }
        return dataValid
    }

    override fun toAnyStruct(): GlAnyStruct {
        return mutableMapOf(
            "uuid" to uuid,
            
            "id" to id, 
            "name" to name, 
            "color" to color
        )
    }
}

// -------------------------------------------------------------------------------------------------

open class TaskRecord : IGlDeclare() {
    var taskID: String = ""
    var groupID: String = ""
    var startTime: Long = 0L
    
    override var uuid: String = randomUUID()
    
    val structDeclare = mapOf< String, KClass< * > >(
        "taskID" to String::class, 
        "groupID" to String::class, 
        "startTime" to Long::class
    )
    
    companion object {
        fun fromAnyStructList(anyStructList: List< * >): List< TaskRecord > {
            return mutableListOf< TaskRecord >().apply {
                for (anyStruct in anyStructList) {
                    val data = TaskRecord().apply { fromAnyStruct(anyStruct) }
                    if (data.dataValid) {
                        this.add(data)
                    }
                }
            }
        }
    }

    override fun fromAnyStruct(data: Any?): Boolean {
        val anyStruct = castToAnyStruct(data)
        dataValid = if (checkStruct(anyStruct, structDeclare)) {
            uuid = (anyStruct.get("uuid") as? String) ?: uuid
            
            taskID = anyStruct.get("taskID") as String
            groupID = anyStruct.get("groupID") as String
            startTime = anyStruct.get("startTime") as Long
            true
        }
        else {
            false
        }
        return dataValid
    }

    override fun toAnyStruct(): GlAnyStruct {
        return mutableMapOf(
            "uuid" to uuid,
            
            "taskID" to taskID, 
            "groupID" to groupID, 
            "startTime" to startTime
        )
    }
}

// -------------------------------------------------------------------------------------------------

open class TaskClass : IGlDeclare() {
    var name: String = ""
    var classification: String = ""
    var period: UInt = 0u
    var batch: UInt = 0u
    var batchSize: UInt = 0u
    
    override var uuid: String = randomUUID()
    
    val structDeclare = mapOf< String, KClass< * > >(
        "name" to String::class, 
        "classification" to String::class, 
        "period" to UInt::class, 
        "batch" to UInt::class, 
        "batchSize" to UInt::class
    )
    
    companion object {
        fun fromAnyStructList(anyStructList: List< * >): List< TaskClass > {
            return mutableListOf< TaskClass >().apply {
                for (anyStruct in anyStructList) {
                    val data = TaskClass().apply { fromAnyStruct(anyStruct) }
                    if (data.dataValid) {
                        this.add(data)
                    }
                }
            }
        }
    }

    override fun fromAnyStruct(data: Any?): Boolean {
        val anyStruct = castToAnyStruct(data)
        dataValid = if (checkStruct(anyStruct, structDeclare)) {
            uuid = (anyStruct.get("uuid") as? String) ?: uuid
            
            name = anyStruct.get("name") as String
            classification = anyStruct.get("classification") as String
            period = anyStruct.get("period") as UInt
            batch = anyStruct.get("batch") as UInt
            batchSize = anyStruct.get("batchSize") as UInt
            true
        }
        else {
            false
        }
        return dataValid
    }

    override fun toAnyStruct(): GlAnyStruct {
        return mutableMapOf(
            "uuid" to uuid,
            
            "name" to name, 
            "classification" to classification, 
            "period" to period, 
            "batch" to batch, 
            "batchSize" to batchSize
        )
    }
}

