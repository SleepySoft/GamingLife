package glcore

import kotlin.reflect.KClass

/*****************************************************************************************
 *
 * This file is generated by GlDataDeclareGen.py
 * You should update GlDataDeclare.json instead of updating this file by manual.
 *
 * ***************************************************************************************/

// -------------------------------------------------------------------------------------------------

open class TaskData : IGlDeclare() {
    var id: String = ""
    var name: String = ""
    var color: String = ""
    
    override var uuid: String = randomUUID()
    
    val structDeclare = mapOf< String, KClass< * > >(
        "id" to String::class, 
        "name" to String::class, 
        "color" to String::class
    )
    
    companion object {
        fun factory(): TaskData = TaskData()
        
        fun fromAnyStructList(anyStructList: List< * >): List< TaskData > {
            return mutableListOf< TaskData >().apply {
                for (anyStruct in anyStructList) {
                    val data = factory().apply { fromAnyStruct(anyStruct) }
                    if (data.dataValid) {
                        this.add(data)
                    }
                }
            }
        }
    }

    override fun fromAnyStruct(data: Any?): Boolean {
        val anyStruct = castToAnyStruct(data)
        
        // Only show warnings
        checkStruct(anyStruct, structDeclare, checkAll=true)
        
        dataValid = try {
            uuid = (anyStruct.get("uuid") as? String) ?: uuid
            
            id = anyStruct["id"] as? String ?: ""
            name = anyStruct["name"] as? String ?: ""
            color = anyStruct["color"] as? String ?: ""
            true
        } catch (e: Exception) {
            println("Parse TaskData fail: $e")
            false
        } finally {
        
        }
        return dataValid
    }

    override fun toAnyStruct(): GlAnyStruct {
        return mutableMapOf(
            "uuid" to uuid,
            
            "id" to id, 
            "name" to name, 
            "color" to color
        )
    }

    override fun copy() : IGlDeclare {
        return TaskData().apply {
            id = this@TaskData.id
            name = this@TaskData.name
            color = this@TaskData.color
        }
    }
}

// -------------------------------------------------------------------------------------------------

open class TaskRecord : IGlDeclare() {
    var taskID: String = ""
    var groupID: String = ""
    var startTime: Long = 0L
    
    override var uuid: String = randomUUID()
    
    val structDeclare = mapOf< String, KClass< * > >(
        "taskID" to String::class, 
        "groupID" to String::class, 
        "startTime" to Long::class
    )
    
    companion object {
        fun factory(): TaskRecord = TaskRecord()
        
        fun fromAnyStructList(anyStructList: List< * >): List< TaskRecord > {
            return mutableListOf< TaskRecord >().apply {
                for (anyStruct in anyStructList) {
                    val data = factory().apply { fromAnyStruct(anyStruct) }
                    if (data.dataValid) {
                        this.add(data)
                    }
                }
            }
        }
    }

    override fun fromAnyStruct(data: Any?): Boolean {
        val anyStruct = castToAnyStruct(data)
        
        // Only show warnings
        checkStruct(anyStruct, structDeclare, checkAll=true)
        
        dataValid = try {
            uuid = (anyStruct.get("uuid") as? String) ?: uuid
            
            taskID = anyStruct["taskID"] as? String ?: ""
            groupID = anyStruct["groupID"] as? String ?: ""
            startTime = anyStruct["startTime"] as? Long ?: 0L
            true
        } catch (e: Exception) {
            println("Parse TaskRecord fail: $e")
            false
        } finally {
        
        }
        return dataValid
    }

    override fun toAnyStruct(): GlAnyStruct {
        return mutableMapOf(
            "uuid" to uuid,
            
            "taskID" to taskID, 
            "groupID" to groupID, 
            "startTime" to startTime
        )
    }

    override fun copy() : IGlDeclare {
        return TaskRecord().apply {
            taskID = this@TaskRecord.taskID
            groupID = this@TaskRecord.groupID
            startTime = this@TaskRecord.startTime
        }
    }
}

// -------------------------------------------------------------------------------------------------

open class PeriodicTask : IGlDeclare() {
    var id: String = ""
    var name: String = ""
    var group: String = ""
    var periodic: Int = 0
    var property: Int = 0
    var timeQuality: Int = 0
    var timeEstimation: Int = 0
    var batch: Int = 0
    var batchSize: Int = 0
    var taskDetail: String = ""
    // This section is for Task Planning
    var dueDateTime: Long = 0L
    // This section is for Task refresh time check
    var refreshTs: Long = 0L
    // This section is for Task Execution and Conclusion
    var batchRemaining: Int = 0
    var conclusion: Int = 0
    var conclusionTs: Long = 0L
    
    override var uuid: String = randomUUID()
    
    val structDeclare = mapOf< String, KClass< * > >(
        "id" to String::class, 
        "name" to String::class, 
        "group" to String::class, 
        "periodic" to Int::class, 
        "property" to Int::class, 
        "timeQuality" to Int::class, 
        "timeEstimation" to Int::class, 
        "batch" to Int::class, 
        "batchSize" to Int::class, 
        "taskDetail" to String::class, 
        "dueDateTime" to Long::class, 
        "refreshTs" to Long::class, 
        "batchRemaining" to Int::class, 
        "conclusion" to Int::class, 
        "conclusionTs" to Long::class
    )
    
    companion object {
        fun factory(): PeriodicTask = PeriodicTask()
        
        fun fromAnyStructList(anyStructList: List< * >): List< PeriodicTask > {
            return mutableListOf< PeriodicTask >().apply {
                for (anyStruct in anyStructList) {
                    val data = factory().apply { fromAnyStruct(anyStruct) }
                    if (data.dataValid) {
                        this.add(data)
                    }
                }
            }
        }
    }

    override fun fromAnyStruct(data: Any?): Boolean {
        val anyStruct = castToAnyStruct(data)
        
        // Only show warnings
        checkStruct(anyStruct, structDeclare, checkAll=true)
        
        dataValid = try {
            uuid = (anyStruct.get("uuid") as? String) ?: uuid
            
            id = anyStruct["id"] as? String ?: ""
            name = anyStruct["name"] as? String ?: ""
            group = anyStruct["group"] as? String ?: ""
            periodic = anyStruct["periodic"] as? Int ?: 0
            property = anyStruct["property"] as? Int ?: 0
            timeQuality = anyStruct["timeQuality"] as? Int ?: 0
            timeEstimation = anyStruct["timeEstimation"] as? Int ?: 0
            batch = anyStruct["batch"] as? Int ?: 0
            batchSize = anyStruct["batchSize"] as? Int ?: 0
            taskDetail = anyStruct["taskDetail"] as? String ?: ""
            dueDateTime = anyStruct["dueDateTime"] as? Long ?: 0L
            refreshTs = anyStruct["refreshTs"] as? Long ?: 0L
            batchRemaining = anyStruct["batchRemaining"] as? Int ?: 0
            conclusion = anyStruct["conclusion"] as? Int ?: 0
            conclusionTs = anyStruct["conclusionTs"] as? Long ?: 0L
            true
        } catch (e: Exception) {
            println("Parse PeriodicTask fail: $e")
            false
        } finally {
        
        }
        return dataValid
    }

    override fun toAnyStruct(): GlAnyStruct {
        return mutableMapOf(
            "uuid" to uuid,
            
            "id" to id, 
            "name" to name, 
            "group" to group, 
            "periodic" to periodic, 
            "property" to property, 
            "timeQuality" to timeQuality, 
            "timeEstimation" to timeEstimation, 
            "batch" to batch, 
            "batchSize" to batchSize, 
            "taskDetail" to taskDetail, 
            "dueDateTime" to dueDateTime, 
            "refreshTs" to refreshTs, 
            "batchRemaining" to batchRemaining, 
            "conclusion" to conclusion, 
            "conclusionTs" to conclusionTs
        )
    }

    override fun copy() : IGlDeclare {
        return PeriodicTask().apply {
            id = this@PeriodicTask.id
            name = this@PeriodicTask.name
            group = this@PeriodicTask.group
            periodic = this@PeriodicTask.periodic
            property = this@PeriodicTask.property
            timeQuality = this@PeriodicTask.timeQuality
            timeEstimation = this@PeriodicTask.timeEstimation
            batch = this@PeriodicTask.batch
            batchSize = this@PeriodicTask.batchSize
            taskDetail = this@PeriodicTask.taskDetail
            dueDateTime = this@PeriodicTask.dueDateTime
            refreshTs = this@PeriodicTask.refreshTs
            batchRemaining = this@PeriodicTask.batchRemaining
            conclusion = this@PeriodicTask.conclusion
            conclusionTs = this@PeriodicTask.conclusionTs
        }
    }
}

// -------------------------------------------------------------------------------------------------

open class StageGoal : IGlDeclare() {
    var taskID: String = ""
    var goalCount: String = ""
    var continuous: Boolean = false
    
    override var uuid: String = randomUUID()
    
    val structDeclare = mapOf< String, KClass< * > >(
        "taskID" to String::class, 
        "goalCount" to String::class, 
        "continuous" to Boolean::class
    )
    
    companion object {
        fun factory(): StageGoal = StageGoal()
        
        fun fromAnyStructList(anyStructList: List< * >): List< StageGoal > {
            return mutableListOf< StageGoal >().apply {
                for (anyStruct in anyStructList) {
                    val data = factory().apply { fromAnyStruct(anyStruct) }
                    if (data.dataValid) {
                        this.add(data)
                    }
                }
            }
        }
    }

    override fun fromAnyStruct(data: Any?): Boolean {
        val anyStruct = castToAnyStruct(data)
        
        // Only show warnings
        checkStruct(anyStruct, structDeclare, checkAll=true)
        
        dataValid = try {
            uuid = (anyStruct.get("uuid") as? String) ?: uuid
            
            taskID = anyStruct["taskID"] as? String ?: ""
            goalCount = anyStruct["goalCount"] as? String ?: ""
            continuous = anyStruct["continuous"] as? Boolean ?: false
            true
        } catch (e: Exception) {
            println("Parse StageGoal fail: $e")
            false
        } finally {
        
        }
        return dataValid
    }

    override fun toAnyStruct(): GlAnyStruct {
        return mutableMapOf(
            "uuid" to uuid,
            
            "taskID" to taskID, 
            "goalCount" to goalCount, 
            "continuous" to continuous
        )
    }

    override fun copy() : IGlDeclare {
        return StageGoal().apply {
            taskID = this@StageGoal.taskID
            goalCount = this@StageGoal.goalCount
            continuous = this@StageGoal.continuous
        }
    }
}

